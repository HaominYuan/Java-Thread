- 什么是重排序？

  - 编译器和 Java 虚拟机通过改变程序的处理顺序来优化程序。

- 为什么重排序在多线程中可能出错？

  - 有一类，那个类中有两个 int 类型的变量 A、B，两个变量都倍初始化为 0。
  - 有两个线程同时持有该实例。其中一个线程是改变这两个变量的大小。另个线程是给出两个变量的大小。
  - 假设第一个线程将变量 A 赋值为 100，将变量 B 赋值为 50。如果在不重排序的情况下，变量 A 是用于不小于变量 B 的。但是在重排序的情况下，变量 B 先被复制为 50，此时变量 A 等于 0。这样就可能导致另一个线程判断出变量 A 小于变量 B。

- 什么是可见性？

  - 假设当前有两个线程 A 、B。此时线程 A 将某个值写入字段 x，而线程 B 读取到了该值。如果线程 B 立刻读取到该值，则称字段 x 是可见的。

- 什么是共享内存？

  - 共享内存是所有线程共享的内存空间，也被称为堆内存。
  - 所有实例且所有实例的字段以及数组都会存放在共享内存中。

- synchronized 关键字小结

  - synchronized 关键字提供了线程互斥以及同步处理两个功能。
  - synchronized 关键字的实现是通过 lock M 和 unlock M 操作实现的，当一个线程执行了 lock M 操作还未执行 unlock M 操作时，另一个线程就无法执行 lock M 操作。
  - Java 内存模型保证当一个线程执行了 unlock M 操作时，在 unlock M 操作之前的所有写入操作都对接下来进行 lock M 操作的线程都可见。
  - 具体的来说就是 lock 操作会使线程中的缓存失效，然后共享内存中的最新内存会被强制重新读取到缓存中。unlock 操作后，写入缓存中的内容会被强制写入到共享内存内存中。

- volatile 关键字小结

  - volatile 关键字提供了同步处理以及对 long 和 double 的原子操作两个功能。
  - volatile 关键字的同步处理是通过两个机制实现的。
    - volatile 关键字会防止重排序。
    - 对被 volatile 关键字修饰的字段的写操作和读操作都是直接在共享内存中进行的。

- final 关键字小结

  - 被 final 关键字修饰的变量只能在字段声明时和构造函数中进行。
  - 在初始化之后保证一下两点
    - final 字段初始化后的值对所有线程可见。
    - final 字段可以追溯到的所有范围内都可以看到正确的值。
  - 在初始化之前保证看到的是默认值，例如 0，false，null。

- 不要从构造函数中泄漏 this。

- Java 内存模型保证 release 终止后对应的 acquire 才开始顺序执行。

  | release                  | acquire                                                      |
  | ------------------------ | ------------------------------------------------------------ |
  | volatile write           | volatile read                                                |
  | unlock                   | lock                                                         |
  | 线程的启动（start）      | 线程启动后的第一个操作                                       |
  | 线程终止前的最后一个操作 | 检测线程的终止（join、isAlive）                              |
  | 中断（interrupt）        | 检测中断（isInterrupted、Thread.interrupted、InterruptedExecution） |
  | 向字段写入默认值         | 线程的第一个操作                                             |