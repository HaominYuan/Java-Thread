- 顺序、并行与并发的区别
  - 顺序表示多个操作在时间维度上依次进行。
  - 并行表示多个操作在时间维度上同时进行。
  - 并发表示多个操作在逻辑上同时进行。
    - 如果有 10 个操作被分为两部分，每个部分都有 5 个操作。当只有一个 CPU 时，并发就是交替的顺序执行。当有多个 CPU 时，并发就是每个部分并行执行。
- 继承 Thread 类和实现 Runnable 接口的区别
  - Thread 类共享变量只能通过另外包装一个参数类实现。
  - Runnable 接口并不需要。我们可以实例化一个实现了 Runnable 接口的方法的类 R，然后将类 R 作为参数传递给 Thread 类。 类 R 可以作为多个 Thread 类的参数，因此实现了变量共享。
- synchronized 关键字用在实例方法、代码块和静态方法的区别
  - synchronized 代码块时，如果其中的参数是 `this` 和 synchronized 实例方法的情况相同。如果其中的参数是 `Class.class` 和 synchronized 静态方法的情况相同。
  - synchronized 实例方法是锁住了该实例的锁。
  - synchronized 静态方法是锁住了该类的锁。
  - 当两个线程锁住了不同的锁时，不会互斥。
- 等待队列、wait 方法、notify 方法、notifyall 方法小结
  - 所有的实例都有等待队列，当一个线程调用 wait 方法时，该线程就会进入该实例的等待队列。
  - 调用 wait 方法之前，该线程必须持有该实例的锁。调用 wait 方法之后，该线程会释放该实例的锁，并进入该实例的等待队列。
  - 调用 notify 方法之前，该线程必须持有该实例的锁。调用 notify 方法之后，该线程会唤醒该实例等待队列中的一个线程 T。调用 notify 方法后，线程并不会释放该实例的锁，锁的释放需要等待线程运行完代码后退出临界区时才释放。
  - notifyall 方法和 notify 方法的区别是，notifyall 方法会唤醒该实例等待队列中的所有线程。
  - 那些从等待队列中被唤醒的线程只是意味着那些线程处于可运行状态，真正运行需要等待虚拟机或者操作系统的调度。
- 多线程的评价标准
  - 安全性。通俗的讲就是实际的结果和预期的结果是否一致。
  - 生存性。通俗的讲就是防止程序因为各种原因停止运行，例如死锁。
  - 复用性。将线程的互斥机制抽取出来，比如 java.util.concurrent 类。
  - 性能。
- 把线程的个数变为 2 倍时，吞吐量也会变为二倍吗？
  - 不会，有两个原因。
  - 线程会进行上下文切换，这里需要花费时间。
  - 每个线程的任务分配不会完美平均。